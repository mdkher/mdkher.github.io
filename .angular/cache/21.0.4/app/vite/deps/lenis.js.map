{
  "version": 3,
  "sources": ["../../../../../../node_modules/lenis/dist/lenis.mjs"],
  "sourcesContent": ["// package.json\nvar version = \"1.3.16\";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchend\",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n  /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for 'touchmove' event */\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = (event) => {\n    this.emitter.emit(\"scroll\", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for 'wheel' event */\n  onWheel = (event) => {\n    let { deltaX, deltaY, deltaMode } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit(\"scroll\", { deltaX, deltaY, event });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar defaultEasing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  __rafID = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don't need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it's used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration,\n    // in seconds\n    easing,\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = \"vertical\",\n    // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false,\n    // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    __experimental__naiveDimensions = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      __experimental__naiveDimensions\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.options.wrapper.addEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoToggle) {\n      this.checkOverflow();\n      this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n        passive: true\n      });\n    }\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      \"scroll\",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  onScrollEnd = (e) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n        e.stopPropagation();\n      }\n    }\n  };\n  dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent(\"scrollend\", {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true\n        }\n      })\n    );\n  };\n  get overflow() {\n    const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n    return getComputedStyle(this.rootElement)[property];\n  }\n  checkOverflow() {\n    if ([\"hidden\", \"clip\"].includes(this.overflow)) {\n      this.internalStop();\n    } else {\n      this.internalStart();\n    }\n  }\n  onTransitionEnd = (event) => {\n    if (event.propertyName.includes(\"overflow\")) {\n      this.checkOverflow();\n    }\n  };\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: \"instant\" });\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: \"instant\" });\n    }\n  }\n  onClick = (event) => {\n    const path = event.composedPath();\n    const anchor = path.find(\n      (node) => node instanceof HTMLAnchorElement && node.getAttribute(\"href\")?.includes(\"#\")\n    );\n    if (anchor) {\n      const href = anchor.getAttribute(\"href\");\n      if (href) {\n        const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n        const target = `#${href.split(\"#\")[1]}`;\n        this.scrollTo(target, options);\n      }\n    }\n  };\n  onPointerDown = (event) => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = (data) => {\n    if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false)\n      return;\n    const { deltaX, deltaY, event } = data;\n    this.emitter.emit(\"virtual-scroll\", { deltaX, deltaY, event });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes(\"touch\");\n    const isWheel = event.type.includes(\"wheel\");\n    this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n    const isClickOrTap = deltaX === 0 && deltaY === 0;\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n    if (isClickOrTap || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(\n      (node) => node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, { deltaX, deltaY }))\n    ))\n      return;\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = \"native\";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === \"both\") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === \"horizontal\") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const isSyncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === \"touchend\";\n    const hasTouchInertia = isTouchEnd;\n    if (hasTouchInertia) {\n      delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...isSyncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n        // immediate: !hasTouchInertia,\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === \"native\") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      );\n      if (!this.isStopped) {\n        this.isScrolling = \"native\";\n      }\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty(\"overflow\");\n      return;\n    }\n    this.internalStart();\n  }\n  internalStart() {\n    if (!this.isStopped) return;\n    this.reset();\n    this.isStopped = false;\n    this.emit();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty(\"overflow\", \"clip\");\n      return;\n    }\n    this.internalStop();\n  }\n  internalStop() {\n    if (this.isStopped) return;\n    this.reset();\n    this.isStopped = true;\n    this.emit();\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time) => {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  };\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    duration = this.options.duration,\n    easing = this.options.easing,\n    lerp: lerp2 = this.options.lerp,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    programmatic = true,\n    // called from outside of the class\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\", \"#\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n        if (!node) {\n          if (target === \"#top\") {\n            target = 0;\n          } else {\n            console.warn(\"Lenis: Target not found\", target);\n          }\n        }\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n        const distance = target - this.animatedScroll;\n        if (distance > this.limit / 2) {\n          target = target - this.limit;\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit;\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  checkNestedScroll(node, { deltaX, deltaY }) {\n    const time = Date.now();\n    const cache = node._lenis ??= {};\n    let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n    const gestureOrientation = this.options.gestureOrientation;\n    if (time - (cache.time ?? 0) > 2e3) {\n      cache.time = Date.now();\n      const computedStyle = window.getComputedStyle(node);\n      cache.computedStyle = computedStyle;\n      const overflowXString = computedStyle.overflowX;\n      const overflowYString = computedStyle.overflowY;\n      hasOverflowX = [\"auto\", \"overlay\", \"scroll\"].includes(overflowXString);\n      hasOverflowY = [\"auto\", \"overlay\", \"scroll\"].includes(overflowYString);\n      cache.hasOverflowX = hasOverflowX;\n      cache.hasOverflowY = hasOverflowY;\n      if (!hasOverflowX && !hasOverflowY) return false;\n      if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n      if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n      scrollWidth = node.scrollWidth;\n      scrollHeight = node.scrollHeight;\n      clientWidth = node.clientWidth;\n      clientHeight = node.clientHeight;\n      isScrollableX = scrollWidth > clientWidth;\n      isScrollableY = scrollHeight > clientHeight;\n      cache.isScrollableX = isScrollableX;\n      cache.isScrollableY = isScrollableY;\n      cache.scrollWidth = scrollWidth;\n      cache.scrollHeight = scrollHeight;\n      cache.clientWidth = clientWidth;\n      cache.clientHeight = clientHeight;\n    } else {\n      isScrollableX = cache.isScrollableX;\n      isScrollableY = cache.isScrollableY;\n      hasOverflowX = cache.hasOverflowX;\n      hasOverflowY = cache.hasOverflowY;\n      scrollWidth = cache.scrollWidth;\n      scrollHeight = cache.scrollHeight;\n      clientWidth = cache.clientWidth;\n      clientHeight = cache.clientHeight;\n    }\n    if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n      return false;\n    }\n    if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY))\n      return false;\n    if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX))\n      return false;\n    let orientation;\n    if (gestureOrientation === \"horizontal\") {\n      orientation = \"x\";\n    } else if (gestureOrientation === \"vertical\") {\n      orientation = \"y\";\n    } else {\n      const isScrollingX = deltaX !== 0;\n      const isScrollingY = deltaY !== 0;\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = \"x\";\n      }\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = \"y\";\n      }\n    }\n    if (!orientation) return false;\n    let scroll, maxScroll, delta, hasOverflow, isScrollable;\n    if (orientation === \"x\") {\n      scroll = node.scrollLeft;\n      maxScroll = scrollWidth - clientWidth;\n      delta = deltaX;\n      hasOverflow = hasOverflowX;\n      isScrollable = isScrollableX;\n    } else if (orientation === \"y\") {\n      scroll = node.scrollTop;\n      maxScroll = scrollHeight - clientHeight;\n      delta = deltaY;\n      hasOverflow = hasOverflowY;\n      isScrollable = isScrollableY;\n    } else {\n      return false;\n    }\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n    return willScroll && hasOverflow && isScrollable;\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.options.autoToggle) className += \" lenis-autoToggle\";\n    if (this.isStopped) className += \" lenis-stopped\";\n    if (this.isLocked) className += \" lenis-locked\";\n    if (this.isScrolling) className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\nexport {\n  Lenis as default\n};\n"],
  "mappings": ";;;;;AACA,IAAI,UAAU;AAGd,SAAS,MAAM,KAAK,OAAO,KAAK;AAC9B,SAAO,KAAK,IAAI,KAAK,KAAK,IAAI,OAAO,GAAG,CAAC;AAC3C;AACA,SAAS,KAAK,GAAG,GAAG,GAAG;AACrB,UAAQ,IAAI,KAAK,IAAI,IAAI;AAC3B;AACA,SAAS,KAAK,GAAG,GAAG,QAAQ,WAAW;AACrC,SAAO,KAAK,GAAG,GAAG,IAAI,KAAK,IAAI,CAAC,SAAS,SAAS,CAAC;AACrD;AACA,SAAS,OAAO,GAAG,GAAG;AACpB,UAAQ,IAAI,IAAI,KAAK;AACvB;AAGA,IAAI,UAAU,MAAM;AAAA,EAClB,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,KAAK;AAAA,EACL,cAAc;AAAA;AAAA,EAEd;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ,WAAW;AACjB,QAAI,CAAC,KAAK,UAAW;AACrB,QAAI,YAAY;AAChB,QAAI,KAAK,YAAY,KAAK,QAAQ;AAChC,WAAK,eAAe;AACpB,YAAM,iBAAiB,MAAM,GAAG,KAAK,cAAc,KAAK,UAAU,CAAC;AACnE,kBAAY,kBAAkB;AAC9B,YAAM,gBAAgB,YAAY,IAAI,KAAK,OAAO,cAAc;AAChE,WAAK,QAAQ,KAAK,QAAQ,KAAK,KAAK,KAAK,QAAQ;AAAA,IACnD,WAAW,KAAK,MAAM;AACpB,WAAK,QAAQ,KAAK,KAAK,OAAO,KAAK,IAAI,KAAK,OAAO,IAAI,SAAS;AAChE,UAAI,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,IAAI;AACtC,aAAK,QAAQ,KAAK;AAClB,oBAAY;AAAA,MACd;AAAA,IACF,OAAO;AACL,WAAK,QAAQ,KAAK;AAClB,kBAAY;AAAA,IACd;AACA,QAAI,WAAW;AACb,WAAK,KAAK;AAAA,IACZ;AACA,SAAK,WAAW,KAAK,OAAO,SAAS;AAAA,EACvC;AAAA;AAAA,EAEA,OAAO;AACL,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,MAAM,IAAI,EAAE,MAAM,OAAO,UAAU,QAAQ,SAAS,SAAS,GAAG;AACrE,SAAK,OAAO,KAAK,QAAQ;AACzB,SAAK,KAAK;AACV,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,cAAc;AACnB,SAAK,YAAY;AACjB,cAAU;AACV,SAAK,WAAW;AAAA,EAClB;AACF;AAGA,SAAS,SAAS,UAAU,OAAO;AACjC,MAAI;AACJ,SAAO,YAAY,MAAM;AACvB,QAAI,UAAU;AACd,iBAAa,KAAK;AAClB,YAAQ,WAAW,MAAM;AACvB,cAAQ;AACR,eAAS,MAAM,SAAS,IAAI;AAAA,IAC9B,GAAG,KAAK;AAAA,EACV;AACF;AAGA,IAAI,aAAa,MAAM;AAAA,EACrB,YAAY,SAAS,SAAS,EAAE,aAAa,MAAM,UAAU,gBAAgB,IAAI,IAAI,CAAC,GAAG;AACvF,SAAK,UAAU;AACf,SAAK,UAAU;AACf,QAAI,YAAY;AACd,WAAK,kBAAkB,SAAS,KAAK,QAAQ,aAAa;AAC1D,UAAI,KAAK,mBAAmB,QAAQ;AAClC,eAAO,iBAAiB,UAAU,KAAK,iBAAiB,KAAK;AAAA,MAC/D,OAAO;AACL,aAAK,wBAAwB,IAAI,eAAe,KAAK,eAAe;AACpE,aAAK,sBAAsB,QAAQ,KAAK,OAAO;AAAA,MACjD;AACA,WAAK,wBAAwB,IAAI,eAAe,KAAK,eAAe;AACpE,WAAK,sBAAsB,QAAQ,KAAK,OAAO;AAAA,IACjD;AACA,SAAK,OAAO;AAAA,EACd;AAAA,EACA,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,eAAe;AAAA,EACf,cAAc;AAAA;AAAA,EAEd;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AACR,SAAK,uBAAuB,WAAW;AACvC,SAAK,uBAAuB,WAAW;AACvC,QAAI,KAAK,YAAY,UAAU,KAAK,iBAAiB;AACnD,aAAO,oBAAoB,UAAU,KAAK,iBAAiB,KAAK;AAAA,IAClE;AAAA,EACF;AAAA,EACA,SAAS,MAAM;AACb,SAAK,gBAAgB;AACrB,SAAK,gBAAgB;AAAA,EACvB;AAAA,EACA,kBAAkB,MAAM;AACtB,QAAI,KAAK,mBAAmB,QAAQ;AAClC,WAAK,QAAQ,OAAO;AACpB,WAAK,SAAS,OAAO;AAAA,IACvB,OAAO;AACL,WAAK,QAAQ,KAAK,QAAQ;AAC1B,WAAK,SAAS,KAAK,QAAQ;AAAA,IAC7B;AAAA,EACF;AAAA,EACA,kBAAkB,MAAM;AACtB,QAAI,KAAK,mBAAmB,QAAQ;AAClC,WAAK,eAAe,KAAK,QAAQ;AACjC,WAAK,cAAc,KAAK,QAAQ;AAAA,IAClC,OAAO;AACL,WAAK,eAAe,KAAK,QAAQ;AACjC,WAAK,cAAc,KAAK,QAAQ;AAAA,IAClC;AAAA,EACF;AAAA,EACA,IAAI,QAAQ;AACV,WAAO;AAAA,MACL,GAAG,KAAK,cAAc,KAAK;AAAA,MAC3B,GAAG,KAAK,eAAe,KAAK;AAAA,IAC9B;AAAA,EACF;AACF;AAGA,IAAI,UAAU,MAAM;AAAA,EAClB,SAAS,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMV,KAAK,UAAU,MAAM;AACnB,QAAI,YAAY,KAAK,OAAO,KAAK,KAAK,CAAC;AACvC,aAAS,IAAI,GAAG,SAAS,UAAU,QAAQ,IAAI,QAAQ,KAAK;AAC1D,gBAAU,CAAC,IAAI,GAAG,IAAI;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,GAAG,OAAO,IAAI;AACZ,SAAK,OAAO,KAAK,GAAG,KAAK,EAAE,MAAM,KAAK,OAAO,KAAK,IAAI,CAAC,EAAE;AACzD,WAAO,MAAM;AACX,WAAK,OAAO,KAAK,IAAI,KAAK,OAAO,KAAK,GAAG,OAAO,CAAC,MAAM,OAAO,CAAC;AAAA,IACjE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,OAAO,UAAU;AACnB,SAAK,OAAO,KAAK,IAAI,KAAK,OAAO,KAAK,GAAG,OAAO,CAAC,MAAM,aAAa,CAAC;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACR,SAAK,SAAS,CAAC;AAAA,EACjB;AACF;AAGA,IAAI,cAAc,MAAM;AACxB,IAAI,kBAAkB,EAAE,SAAS,MAAM;AACvC,IAAI,gBAAgB,MAAM;AAAA,EACxB,YAAY,SAAS,UAAU,EAAE,iBAAiB,GAAG,iBAAiB,EAAE,GAAG;AACzE,SAAK,UAAU;AACf,SAAK,UAAU;AACf,WAAO,iBAAiB,UAAU,KAAK,gBAAgB,KAAK;AAC5D,SAAK,eAAe;AACpB,SAAK,QAAQ,iBAAiB,SAAS,KAAK,SAAS,eAAe;AACpE,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AACA,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AACA,SAAK,QAAQ,iBAAiB,YAAY,KAAK,YAAY,eAAe;AAAA,EAC5E;AAAA,EACA,aAAa;AAAA,IACX,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AAAA,EACA,YAAY;AAAA,IACV,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AAAA,EACA,SAAS;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AAAA,EACA,UAAU,IAAI,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtB,GAAG,OAAO,UAAU;AAClB,WAAO,KAAK,QAAQ,GAAG,OAAO,QAAQ;AAAA,EACxC;AAAA;AAAA,EAEA,UAAU;AACR,SAAK,QAAQ,QAAQ;AACrB,WAAO,oBAAoB,UAAU,KAAK,gBAAgB,KAAK;AAC/D,SAAK,QAAQ,oBAAoB,SAAS,KAAK,SAAS,eAAe;AACvE,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AACA,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AACA,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,CAAC,UAAU;AACxB,UAAM,EAAE,SAAS,QAAQ,IAAI,MAAM,gBAAgB,MAAM,cAAc,CAAC,IAAI;AAC5E,SAAK,WAAW,IAAI;AACpB,SAAK,WAAW,IAAI;AACpB,SAAK,YAAY;AAAA,MACf,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AACA,SAAK,QAAQ,KAAK,UAAU;AAAA,MAC1B,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA,EAEA,cAAc,CAAC,UAAU;AACvB,UAAM,EAAE,SAAS,QAAQ,IAAI,MAAM,gBAAgB,MAAM,cAAc,CAAC,IAAI;AAC5E,UAAM,SAAS,EAAE,UAAU,KAAK,WAAW,KAAK,KAAK,QAAQ;AAC7D,UAAM,SAAS,EAAE,UAAU,KAAK,WAAW,KAAK,KAAK,QAAQ;AAC7D,SAAK,WAAW,IAAI;AACpB,SAAK,WAAW,IAAI;AACpB,SAAK,YAAY;AAAA,MACf,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AACA,SAAK,QAAQ,KAAK,UAAU;AAAA,MAC1B;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,aAAa,CAAC,UAAU;AACtB,SAAK,QAAQ,KAAK,UAAU;AAAA,MAC1B,QAAQ,KAAK,UAAU;AAAA,MACvB,QAAQ,KAAK,UAAU;AAAA,MACvB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA,EAEA,UAAU,CAAC,UAAU;AACnB,QAAI,EAAE,QAAQ,QAAQ,UAAU,IAAI;AACpC,UAAM,cAAc,cAAc,IAAI,cAAc,cAAc,IAAI,KAAK,OAAO,QAAQ;AAC1F,UAAM,cAAc,cAAc,IAAI,cAAc,cAAc,IAAI,KAAK,OAAO,SAAS;AAC3F,cAAU;AACV,cAAU;AACV,cAAU,KAAK,QAAQ;AACvB,cAAU,KAAK,QAAQ;AACvB,SAAK,QAAQ,KAAK,UAAU,EAAE,QAAQ,QAAQ,MAAM,CAAC;AAAA,EACvD;AAAA,EACA,iBAAiB,MAAM;AACrB,SAAK,SAAS;AAAA,MACZ,OAAO,OAAO;AAAA,MACd,QAAQ,OAAO;AAAA,IACjB;AAAA,EACF;AACF;AAGA,IAAI,gBAAgB,CAAC,MAAM,KAAK,IAAI,GAAG,QAAQ,KAAK,IAAI,GAAG,MAAM,CAAC,CAAC;AACnE,IAAI,QAAQ,MAAM;AAAA,EAChB,eAAe;AAAA;AAAA,EAEf,aAAa;AAAA;AAAA,EAEb,YAAY;AAAA;AAAA,EAEZ,gCAAgC;AAAA,EAChC,wBAAwB;AAAA,EACxB,UAAU;AAAA;AAAA;AAAA;AAAA,EAIV;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWP,WAAW,CAAC;AAAA;AAAA;AAAA;AAAA,EAIZ,eAAe;AAAA;AAAA;AAAA;AAAA,EAIf,WAAW;AAAA;AAAA;AAAA;AAAA,EAIX,YAAY;AAAA;AAAA;AAAA;AAAA,EAIZ;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA,EAEA,UAAU,IAAI,QAAQ;AAAA,EACtB,UAAU,IAAI,QAAQ;AAAA;AAAA,EAEtB;AAAA;AAAA,EAEA;AAAA,EACA,YAAY;AAAA,IACV,UAAU;AAAA,IACV,UAAU,SAAS;AAAA,IACnB,eAAe;AAAA,IACf,cAAc;AAAA,IACd,YAAY;AAAA,IACZ,gBAAgB;AAAA,IAChB,uBAAuB;AAAA,IACvB;AAAA;AAAA,IAEA;AAAA,IACA,MAAM,QAAQ;AAAA,IACd,WAAW;AAAA,IACX,cAAc;AAAA;AAAA,IAEd,qBAAqB,gBAAgB,eAAe,SAAS;AAAA;AAAA,IAE7D,kBAAkB;AAAA,IAClB,kBAAkB;AAAA,IAClB,aAAa;AAAA,IACb;AAAA,IACA;AAAA,IACA,aAAa;AAAA,IACb,UAAU;AAAA,IACV,UAAU;AAAA,IACV,aAAa;AAAA;AAAA,IAEb,oBAAoB;AAAA,IACpB,kCAAkC;AAAA,EACpC,IAAI,CAAC,GAAG;AACN,WAAO,eAAe;AACtB,QAAI,CAAC,WAAW,YAAY,SAAS,iBAAiB;AACpD,gBAAU;AAAA,IACZ;AACA,QAAI,OAAO,aAAa,YAAY,OAAO,WAAW,YAAY;AAChE,eAAS;AAAA,IACX,WAAW,OAAO,WAAW,cAAc,OAAO,aAAa,UAAU;AACvE,iBAAW;AAAA,IACb;AACA,SAAK,UAAU;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,SAAK,aAAa,IAAI,WAAW,SAAS,SAAS,EAAE,WAAW,CAAC;AACjE,SAAK,gBAAgB;AACrB,SAAK,eAAe,KAAK,iBAAiB,KAAK;AAC/C,SAAK,QAAQ,QAAQ,iBAAiB,UAAU,KAAK,gBAAgB,KAAK;AAC1E,SAAK,QAAQ,QAAQ,iBAAiB,aAAa,KAAK,aAAa;AAAA,MACnE,SAAS;AAAA,IACX,CAAC;AACD,QAAI,KAAK,QAAQ,WAAW,KAAK,QAAQ,YAAY,QAAQ;AAC3D,WAAK,QAAQ,QAAQ;AAAA,QACnB;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MACF;AAAA,IACF;AACA,SAAK,QAAQ,QAAQ;AAAA,MACnB;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AACA,SAAK,gBAAgB,IAAI,cAAc,cAAc;AAAA,MACnD;AAAA,MACA;AAAA,IACF,CAAC;AACD,SAAK,cAAc,GAAG,UAAU,KAAK,eAAe;AACpD,QAAI,KAAK,QAAQ,YAAY;AAC3B,WAAK,cAAc;AACnB,WAAK,YAAY,iBAAiB,iBAAiB,KAAK,iBAAiB;AAAA,QACvE,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AACA,QAAI,KAAK,QAAQ,SAAS;AACxB,WAAK,UAAU,sBAAsB,KAAK,GAAG;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACR,SAAK,QAAQ,QAAQ;AACrB,SAAK,QAAQ,QAAQ;AAAA,MACnB;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AACA,SAAK,QAAQ,QAAQ,oBAAoB,aAAa,KAAK,aAAa;AAAA,MACtE,SAAS;AAAA,IACX,CAAC;AACD,SAAK,QAAQ,QAAQ;AAAA,MACnB;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AACA,QAAI,KAAK,QAAQ,WAAW,KAAK,QAAQ,YAAY,QAAQ;AAC3D,WAAK,QAAQ,QAAQ;AAAA,QACnB;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MACF;AAAA,IACF;AACA,SAAK,cAAc,QAAQ;AAC3B,SAAK,WAAW,QAAQ;AACxB,SAAK,iBAAiB;AACtB,QAAI,KAAK,SAAS;AAChB,2BAAqB,KAAK,OAAO;AAAA,IACnC;AAAA,EACF;AAAA,EACA,GAAG,OAAO,UAAU;AAClB,WAAO,KAAK,QAAQ,GAAG,OAAO,QAAQ;AAAA,EACxC;AAAA,EACA,IAAI,OAAO,UAAU;AACnB,WAAO,KAAK,QAAQ,IAAI,OAAO,QAAQ;AAAA,EACzC;AAAA,EACA,cAAc,CAAC,MAAM;AACnB,QAAI,EAAE,aAAa,cAAc;AAC/B,UAAI,KAAK,gBAAgB,YAAY,KAAK,gBAAgB,OAAO;AAC/D,UAAE,gBAAgB;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAAA,EACA,yBAAyB,MAAM;AAC7B,SAAK,QAAQ,QAAQ;AAAA,MACnB,IAAI,YAAY,aAAa;AAAA,QAC3B,SAAS,KAAK,QAAQ,YAAY;AAAA;AAAA,QAElC,QAAQ;AAAA,UACN,gBAAgB;AAAA,QAClB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,IAAI,WAAW;AACb,UAAM,WAAW,KAAK,eAAe,eAAe;AACpD,WAAO,iBAAiB,KAAK,WAAW,EAAE,QAAQ;AAAA,EACpD;AAAA,EACA,gBAAgB;AACd,QAAI,CAAC,UAAU,MAAM,EAAE,SAAS,KAAK,QAAQ,GAAG;AAC9C,WAAK,aAAa;AAAA,IACpB,OAAO;AACL,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AAAA,EACA,kBAAkB,CAAC,UAAU;AAC3B,QAAI,MAAM,aAAa,SAAS,UAAU,GAAG;AAC3C,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AAAA,EACA,UAAU,QAAQ;AAChB,QAAI,KAAK,cAAc;AACrB,WAAK,QAAQ,QAAQ,SAAS,EAAE,MAAM,QAAQ,UAAU,UAAU,CAAC;AAAA,IACrE,OAAO;AACL,WAAK,QAAQ,QAAQ,SAAS,EAAE,KAAK,QAAQ,UAAU,UAAU,CAAC;AAAA,IACpE;AAAA,EACF;AAAA,EACA,UAAU,CAAC,UAAU;AACnB,UAAM,OAAO,MAAM,aAAa;AAChC,UAAM,SAAS,KAAK;AAAA,MAClB,CAAC,SAAS,gBAAgB,qBAAqB,KAAK,aAAa,MAAM,GAAG,SAAS,GAAG;AAAA,IACxF;AACA,QAAI,QAAQ;AACV,YAAM,OAAO,OAAO,aAAa,MAAM;AACvC,UAAI,MAAM;AACR,cAAM,UAAU,OAAO,KAAK,QAAQ,YAAY,YAAY,KAAK,QAAQ,UAAU,KAAK,QAAQ,UAAU;AAC1G,cAAM,SAAS,IAAI,KAAK,MAAM,GAAG,EAAE,CAAC,CAAC;AACrC,aAAK,SAAS,QAAQ,OAAO;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAAA,EACA,gBAAgB,CAAC,UAAU;AACzB,QAAI,MAAM,WAAW,GAAG;AACtB,WAAK,MAAM;AAAA,IACb;AAAA,EACF;AAAA,EACA,kBAAkB,CAAC,SAAS;AAC1B,QAAI,OAAO,KAAK,QAAQ,kBAAkB,cAAc,KAAK,QAAQ,cAAc,IAAI,MAAM;AAC3F;AACF,UAAM,EAAE,QAAQ,QAAQ,MAAM,IAAI;AAClC,SAAK,QAAQ,KAAK,kBAAkB,EAAE,QAAQ,QAAQ,MAAM,CAAC;AAC7D,QAAI,MAAM,QAAS;AACnB,QAAI,MAAM,qBAAsB;AAChC,UAAM,UAAU,MAAM,KAAK,SAAS,OAAO;AAC3C,UAAM,UAAU,MAAM,KAAK,SAAS,OAAO;AAC3C,SAAK,aAAa,MAAM,SAAS,gBAAgB,MAAM,SAAS;AAChE,UAAM,eAAe,WAAW,KAAK,WAAW;AAChD,UAAM,cAAc,KAAK,QAAQ,aAAa,WAAW,MAAM,SAAS,gBAAgB,gBAAgB,CAAC,KAAK,aAAa,CAAC,KAAK;AACjI,QAAI,aAAa;AACf,WAAK,MAAM;AACX;AAAA,IACF;AACA,UAAM,mBAAmB,KAAK,QAAQ,uBAAuB,cAAc,WAAW,KAAK,KAAK,QAAQ,uBAAuB,gBAAgB,WAAW;AAC1J,QAAI,gBAAgB,kBAAkB;AACpC;AAAA,IACF;AACA,QAAI,eAAe,MAAM,aAAa;AACtC,mBAAe,aAAa,MAAM,GAAG,aAAa,QAAQ,KAAK,WAAW,CAAC;AAC3E,UAAM,UAAU,KAAK,QAAQ;AAC7B,QAAI,CAAC,CAAC,aAAa;AAAA,MACjB,CAAC,SAAS,gBAAgB,gBAAgB,OAAO,YAAY,cAAc,UAAU,IAAI,KAAK,KAAK,eAAe,oBAAoB,KAAK,WAAW,KAAK,eAAe,0BAA0B,KAAK,WAAW,KAAK,eAAe,0BAA0B,KAAK,KAAK,QAAQ,qBAAqB,KAAK,kBAAkB,MAAM,EAAE,QAAQ,OAAO,CAAC;AAAA,IAC1V;AACE;AACF,QAAI,KAAK,aAAa,KAAK,UAAU;AACnC,UAAI,MAAM,YAAY;AACpB,cAAM,eAAe;AAAA,MACvB;AACA;AAAA,IACF;AACA,UAAM,WAAW,KAAK,QAAQ,aAAa,WAAW,KAAK,QAAQ,eAAe;AAClF,QAAI,CAAC,UAAU;AACb,WAAK,cAAc;AACnB,WAAK,QAAQ,KAAK;AAClB,YAAM,uBAAuB;AAC7B;AAAA,IACF;AACA,QAAI,QAAQ;AACZ,QAAI,KAAK,QAAQ,uBAAuB,QAAQ;AAC9C,cAAQ,KAAK,IAAI,MAAM,IAAI,KAAK,IAAI,MAAM,IAAI,SAAS;AAAA,IACzD,WAAW,KAAK,QAAQ,uBAAuB,cAAc;AAC3D,cAAQ;AAAA,IACV;AACA,QAAI,CAAC,KAAK,QAAQ,cAAc,KAAK,QAAQ,YAAY,KAAK,QAAQ,YAAY,UAAU,KAAK,QAAQ,MAAM,KAAK,iBAAiB,KAAK,KAAK,iBAAiB,KAAK,SAAS,KAAK,mBAAmB,KAAK,SAAS,KAAK,KAAK,mBAAmB,KAAK,SAAS,SAAS,IAAI;AAC1Q,YAAM,uBAAuB;AAAA,IAC/B;AACA,QAAI,MAAM,YAAY;AACpB,YAAM,eAAe;AAAA,IACvB;AACA,UAAM,cAAc,WAAW,KAAK,QAAQ;AAC5C,UAAM,aAAa,WAAW,MAAM,SAAS;AAC7C,UAAM,kBAAkB;AACxB,QAAI,iBAAiB;AACnB,cAAQ,KAAK,KAAK,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,QAAQ,GAAG,KAAK,QAAQ,oBAAoB;AAAA,IACxG;AACA,SAAK,SAAS,KAAK,eAAe,OAAO;AAAA,MACvC,cAAc;AAAA,OACX,cAAc;AAAA,MACf,MAAM,kBAAkB,KAAK,QAAQ,gBAAgB;AAAA;AAAA,IAEvD,IAAI;AAAA,MACF,MAAM,KAAK,QAAQ;AAAA,MACnB,UAAU,KAAK,QAAQ;AAAA,MACvB,QAAQ,KAAK,QAAQ;AAAA,IACvB,EACD;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS;AACP,SAAK,WAAW,OAAO;AACvB,SAAK,iBAAiB,KAAK,eAAe,KAAK;AAC/C,SAAK,KAAK;AAAA,EACZ;AAAA,EACA,OAAO;AACL,SAAK,QAAQ,KAAK,UAAU,IAAI;AAAA,EAClC;AAAA,EACA,iBAAiB,MAAM;AACrB,QAAI,KAAK,0BAA0B,MAAM;AACvC,mBAAa,KAAK,qBAAqB;AACvC,WAAK,wBAAwB;AAAA,IAC/B;AACA,QAAI,KAAK,+BAA+B;AACtC,WAAK,gCAAgC;AACrC;AAAA,IACF;AACA,QAAI,KAAK,gBAAgB,SAAS,KAAK,gBAAgB,UAAU;AAC/D,YAAM,aAAa,KAAK;AACxB,WAAK,iBAAiB,KAAK,eAAe,KAAK;AAC/C,WAAK,eAAe,KAAK;AACzB,WAAK,WAAW,KAAK,iBAAiB;AACtC,WAAK,YAAY,KAAK;AAAA,QACpB,KAAK,iBAAiB;AAAA,MACxB;AACA,UAAI,CAAC,KAAK,WAAW;AACnB,aAAK,cAAc;AAAA,MACrB;AACA,WAAK,KAAK;AACV,UAAI,KAAK,aAAa,GAAG;AACvB,aAAK,wBAAwB,WAAW,MAAM;AAC5C,eAAK,eAAe,KAAK;AACzB,eAAK,WAAW;AAChB,eAAK,cAAc;AACnB,eAAK,KAAK;AAAA,QACZ,GAAG,GAAG;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EACA,QAAQ;AACN,SAAK,WAAW;AAChB,SAAK,cAAc;AACnB,SAAK,iBAAiB,KAAK,eAAe,KAAK;AAC/C,SAAK,eAAe,KAAK,WAAW;AACpC,SAAK,QAAQ,KAAK;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ;AACN,QAAI,CAAC,KAAK,UAAW;AACrB,QAAI,KAAK,QAAQ,YAAY;AAC3B,WAAK,YAAY,MAAM,eAAe,UAAU;AAChD;AAAA,IACF;AACA,SAAK,cAAc;AAAA,EACrB;AAAA,EACA,gBAAgB;AACd,QAAI,CAAC,KAAK,UAAW;AACrB,SAAK,MAAM;AACX,SAAK,YAAY;AACjB,SAAK,KAAK;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO;AACL,QAAI,KAAK,UAAW;AACpB,QAAI,KAAK,QAAQ,YAAY;AAC3B,WAAK,YAAY,MAAM,YAAY,YAAY,MAAM;AACrD;AAAA,IACF;AACA,SAAK,aAAa;AAAA,EACpB;AAAA,EACA,eAAe;AACb,QAAI,KAAK,UAAW;AACpB,SAAK,MAAM;AACX,SAAK,YAAY;AACjB,SAAK,KAAK;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,CAAC,SAAS;AACd,UAAM,YAAY,QAAQ,KAAK,QAAQ;AACvC,SAAK,OAAO;AACZ,SAAK,QAAQ,QAAQ,YAAY,IAAI;AACrC,QAAI,KAAK,QAAQ,SAAS;AACxB,WAAK,UAAU,sBAAsB,KAAK,GAAG;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,SAAS,QAAQ;AAAA,IACf,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,WAAW,KAAK,QAAQ;AAAA,IACxB,SAAS,KAAK,QAAQ;AAAA,IACtB,MAAM,QAAQ,KAAK,QAAQ;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,QAAQ;AAAA;AAAA,IAER,eAAe;AAAA;AAAA,IAEf;AAAA,EACF,IAAI,CAAC,GAAG;AACN,SAAK,KAAK,aAAa,KAAK,aAAa,CAAC,MAAO;AACjD,QAAI,OAAO,WAAW,YAAY,CAAC,OAAO,QAAQ,SAAS,GAAG,EAAE,SAAS,MAAM,GAAG;AAChF,eAAS;AAAA,IACX,WAAW,OAAO,WAAW,YAAY,CAAC,UAAU,SAAS,KAAK,EAAE,SAAS,MAAM,GAAG;AACpF,eAAS,KAAK;AAAA,IAChB,OAAO;AACL,UAAI;AACJ,UAAI,OAAO,WAAW,UAAU;AAC9B,eAAO,SAAS,cAAc,MAAM;AACpC,YAAI,CAAC,MAAM;AACT,cAAI,WAAW,QAAQ;AACrB,qBAAS;AAAA,UACX,OAAO;AACL,oBAAQ,KAAK,2BAA2B,MAAM;AAAA,UAChD;AAAA,QACF;AAAA,MACF,WAAW,kBAAkB,eAAe,QAAQ,UAAU;AAC5D,eAAO;AAAA,MACT;AACA,UAAI,MAAM;AACR,YAAI,KAAK,QAAQ,YAAY,QAAQ;AACnC,gBAAM,cAAc,KAAK,YAAY,sBAAsB;AAC3D,oBAAU,KAAK,eAAe,YAAY,OAAO,YAAY;AAAA,QAC/D;AACA,cAAM,OAAO,KAAK,sBAAsB;AACxC,kBAAU,KAAK,eAAe,KAAK,OAAO,KAAK,OAAO,KAAK;AAAA,MAC7D;AAAA,IACF;AACA,QAAI,OAAO,WAAW,SAAU;AAChC,cAAU;AACV,aAAS,KAAK,MAAM,MAAM;AAC1B,QAAI,KAAK,QAAQ,UAAU;AACzB,UAAI,cAAc;AAChB,aAAK,eAAe,KAAK,iBAAiB,KAAK;AAC/C,cAAM,WAAW,SAAS,KAAK;AAC/B,YAAI,WAAW,KAAK,QAAQ,GAAG;AAC7B,mBAAS,SAAS,KAAK;AAAA,QACzB,WAAW,WAAW,CAAC,KAAK,QAAQ,GAAG;AACrC,mBAAS,SAAS,KAAK;AAAA,QACzB;AAAA,MACF;AAAA,IACF,OAAO;AACL,eAAS,MAAM,GAAG,QAAQ,KAAK,KAAK;AAAA,IACtC;AACA,QAAI,WAAW,KAAK,cAAc;AAChC,gBAAU,IAAI;AACd,mBAAa,IAAI;AACjB;AAAA,IACF;AACA,SAAK,WAAW,YAAY,CAAC;AAC7B,QAAI,WAAW;AACb,WAAK,iBAAiB,KAAK,eAAe;AAC1C,WAAK,UAAU,KAAK,MAAM;AAC1B,WAAK,MAAM;AACX,WAAK,6BAA6B;AAClC,WAAK,KAAK;AACV,mBAAa,IAAI;AACjB,WAAK,WAAW,CAAC;AACjB,4BAAsB,MAAM;AAC1B,aAAK,uBAAuB;AAAA,MAC9B,CAAC;AACD;AAAA,IACF;AACA,QAAI,CAAC,cAAc;AACjB,WAAK,eAAe;AAAA,IACtB;AACA,QAAI,OAAO,aAAa,YAAY,OAAO,WAAW,YAAY;AAChE,eAAS;AAAA,IACX,WAAW,OAAO,WAAW,cAAc,OAAO,aAAa,UAAU;AACvE,iBAAW;AAAA,IACb;AACA,SAAK,QAAQ,OAAO,KAAK,gBAAgB,QAAQ;AAAA,MAC/C;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN,SAAS,MAAM;AACb,YAAI,KAAM,MAAK,WAAW;AAC1B,aAAK,cAAc;AACnB,kBAAU,IAAI;AAAA,MAChB;AAAA,MACA,UAAU,CAAC,OAAO,cAAc;AAC9B,aAAK,cAAc;AACnB,aAAK,eAAe,KAAK;AACzB,aAAK,WAAW,QAAQ,KAAK;AAC7B,aAAK,YAAY,KAAK,KAAK,KAAK,QAAQ;AACxC,aAAK,iBAAiB;AACtB,aAAK,UAAU,KAAK,MAAM;AAC1B,YAAI,cAAc;AAChB,eAAK,eAAe;AAAA,QACtB;AACA,YAAI,CAAC,UAAW,MAAK,KAAK;AAC1B,YAAI,WAAW;AACb,eAAK,MAAM;AACX,eAAK,KAAK;AACV,uBAAa,IAAI;AACjB,eAAK,WAAW,CAAC;AACjB,gCAAsB,MAAM;AAC1B,iBAAK,uBAAuB;AAAA,UAC9B,CAAC;AACD,eAAK,6BAA6B;AAAA,QACpC;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,+BAA+B;AAC7B,SAAK,gCAAgC;AACrC,0BAAsB,MAAM;AAC1B,WAAK,gCAAgC;AAAA,IACvC,CAAC;AAAA,EACH;AAAA,EACA,kBAAkB,MAAM,EAAE,QAAQ,OAAO,GAAG;AAC1C,UAAM,OAAO,KAAK,IAAI;AACtB,UAAM,QAAQ,KAAK,WAAW,CAAC;AAC/B,QAAI,cAAc,cAAc,eAAe,eAAe,aAAa,cAAc,aAAa;AACtG,UAAM,qBAAqB,KAAK,QAAQ;AACxC,QAAI,QAAQ,MAAM,QAAQ,KAAK,KAAK;AAClC,YAAM,OAAO,KAAK,IAAI;AACtB,YAAM,gBAAgB,OAAO,iBAAiB,IAAI;AAClD,YAAM,gBAAgB;AACtB,YAAM,kBAAkB,cAAc;AACtC,YAAM,kBAAkB,cAAc;AACtC,qBAAe,CAAC,QAAQ,WAAW,QAAQ,EAAE,SAAS,eAAe;AACrE,qBAAe,CAAC,QAAQ,WAAW,QAAQ,EAAE,SAAS,eAAe;AACrE,YAAM,eAAe;AACrB,YAAM,eAAe;AACrB,UAAI,CAAC,gBAAgB,CAAC,aAAc,QAAO;AAC3C,UAAI,uBAAuB,cAAc,CAAC,aAAc,QAAO;AAC/D,UAAI,uBAAuB,gBAAgB,CAAC,aAAc,QAAO;AACjE,oBAAc,KAAK;AACnB,qBAAe,KAAK;AACpB,oBAAc,KAAK;AACnB,qBAAe,KAAK;AACpB,sBAAgB,cAAc;AAC9B,sBAAgB,eAAe;AAC/B,YAAM,gBAAgB;AACtB,YAAM,gBAAgB;AACtB,YAAM,cAAc;AACpB,YAAM,eAAe;AACrB,YAAM,cAAc;AACpB,YAAM,eAAe;AAAA,IACvB,OAAO;AACL,sBAAgB,MAAM;AACtB,sBAAgB,MAAM;AACtB,qBAAe,MAAM;AACrB,qBAAe,MAAM;AACrB,oBAAc,MAAM;AACpB,qBAAe,MAAM;AACrB,oBAAc,MAAM;AACpB,qBAAe,MAAM;AAAA,IACvB;AACA,QAAI,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,eAAe;AACtE,aAAO;AAAA,IACT;AACA,QAAI,uBAAuB,eAAe,CAAC,gBAAgB,CAAC;AAC1D,aAAO;AACT,QAAI,uBAAuB,iBAAiB,CAAC,gBAAgB,CAAC;AAC5D,aAAO;AACT,QAAI;AACJ,QAAI,uBAAuB,cAAc;AACvC,oBAAc;AAAA,IAChB,WAAW,uBAAuB,YAAY;AAC5C,oBAAc;AAAA,IAChB,OAAO;AACL,YAAM,eAAe,WAAW;AAChC,YAAM,eAAe,WAAW;AAChC,UAAI,gBAAgB,gBAAgB,eAAe;AACjD,sBAAc;AAAA,MAChB;AACA,UAAI,gBAAgB,gBAAgB,eAAe;AACjD,sBAAc;AAAA,MAChB;AAAA,IACF;AACA,QAAI,CAAC,YAAa,QAAO;AACzB,QAAI,QAAQ,WAAW,OAAO,aAAa;AAC3C,QAAI,gBAAgB,KAAK;AACvB,eAAS,KAAK;AACd,kBAAY,cAAc;AAC1B,cAAQ;AACR,oBAAc;AACd,qBAAe;AAAA,IACjB,WAAW,gBAAgB,KAAK;AAC9B,eAAS,KAAK;AACd,kBAAY,eAAe;AAC3B,cAAQ;AACR,oBAAc;AACd,qBAAe;AAAA,IACjB,OAAO;AACL,aAAO;AAAA,IACT;AACA,UAAM,aAAa,QAAQ,IAAI,SAAS,YAAY,SAAS;AAC7D,WAAO,cAAc,eAAe;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,cAAc;AAChB,WAAO,KAAK,QAAQ,YAAY,SAAS,SAAS,kBAAkB,KAAK,QAAQ;AAAA,EACnF;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,QAAQ;AACV,QAAI,KAAK,QAAQ,iCAAiC;AAChD,UAAI,KAAK,cAAc;AACrB,eAAO,KAAK,YAAY,cAAc,KAAK,YAAY;AAAA,MACzD,OAAO;AACL,eAAO,KAAK,YAAY,eAAe,KAAK,YAAY;AAAA,MAC1D;AAAA,IACF,OAAO;AACL,aAAO,KAAK,WAAW,MAAM,KAAK,eAAe,MAAM,GAAG;AAAA,IAC5D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,eAAe;AACjB,WAAO,KAAK,QAAQ,gBAAgB;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,eAAe;AACjB,UAAM,UAAU,KAAK,QAAQ;AAC7B,WAAO,KAAK,eAAe,QAAQ,WAAW,QAAQ,aAAa,QAAQ,WAAW,QAAQ;AAAA,EAChG;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,SAAS;AACX,WAAO,KAAK,QAAQ,WAAW,OAAO,KAAK,gBAAgB,KAAK,KAAK,IAAI,KAAK;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,WAAW;AACb,WAAO,KAAK,UAAU,IAAI,IAAI,KAAK,SAAS,KAAK;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,cAAc;AAChB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,YAAY,OAAO;AACrB,QAAI,KAAK,iBAAiB,OAAO;AAC/B,WAAK,eAAe;AACpB,WAAK,gBAAgB;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,YAAY;AACd,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,UAAU,OAAO;AACnB,QAAI,KAAK,eAAe,OAAO;AAC7B,WAAK,aAAa;AAClB,WAAK,gBAAgB;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,SAAS,OAAO;AAClB,QAAI,KAAK,cAAc,OAAO;AAC5B,WAAK,YAAY;AACjB,WAAK,gBAAgB;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,WAAW;AACb,WAAO,KAAK,gBAAgB;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,YAAY;AACd,QAAI,YAAY;AAChB,QAAI,KAAK,QAAQ,WAAY,cAAa;AAC1C,QAAI,KAAK,UAAW,cAAa;AACjC,QAAI,KAAK,SAAU,cAAa;AAChC,QAAI,KAAK,YAAa,cAAa;AACnC,QAAI,KAAK,gBAAgB,SAAU,cAAa;AAChD,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB;AAChB,SAAK,iBAAiB;AACtB,SAAK,YAAY,YAAY,GAAG,KAAK,YAAY,SAAS,IAAI,KAAK,SAAS,GAAG,KAAK;AAAA,EACtF;AAAA,EACA,mBAAmB;AACjB,SAAK,YAAY,YAAY,KAAK,YAAY,UAAU,QAAQ,iBAAiB,EAAE,EAAE,KAAK;AAAA,EAC5F;AACF;",
  "names": []
}
